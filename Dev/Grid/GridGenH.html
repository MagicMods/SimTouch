<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Circular Grid Generator</title>

    <style>
      canvas {
        border: 2px solid black;
        display: block;
        margin: auto;
      }
    </style>
    <!-- Include lil-gui stylesheet -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/lil-gui/0.17/lil-gui.min.css"
    />
  </head>
  <body>
    <canvas id="myCanvas" width="240" height="240"></canvas>
    <!-- Include lil-gui library -->
    <script type="module">
      import GUI from "./node_modules/lil-gui/dist/lil-gui.esm.min.js";

      const canvas = document.getElementById("myCanvas");
      const gl = canvas.getContext("webgl");
      const lil = { GUI };

      if (!gl) {
        console.error("WebGL not supported");
      }

      // Vertex shader program
      const vsSource = `
        attribute vec2 aPosition;
        uniform vec2 uResolution;
        void main() {
            vec2 zeroToOne = aPosition / uResolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
      `;

      // Fragment shader program
      const fsSource = `
        precision mediump float;
        uniform vec4 uColor;
        void main() {
            gl_FragColor = uColor;
        }
      `;

      // Initialize shaders
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          console.error(
            "Unable to initialize the shader program:",
            gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }

        return shaderProgram;
      }

      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "An error occurred compiling the shaders:",
            gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          position: gl.getAttribLocation(shaderProgram, "aPosition"),
        },
        uniformLocations: {
          resolution: gl.getUniformLocation(shaderProgram, "uResolution"),
          color: gl.getUniformLocation(shaderProgram, "uColor"),
        },
      };

      // Parameters for grid generation
      const params = {
        target: 100, // Target number of rectangles
        gap: 2, // Gap between rectangles in pixels
        aspectRatio: 1, // Rectangle width/height ratio (1 for square, >1 for landscape)
      };

      // Generate grid rectangles based on current parameters.
      // The grid is computed to be centered in the canvas (which is 240x240)
      // and fully contained within a circle of radius 120 centered at (120,120).
      function generateRectangles() {
        // Determine grid dimensions (rows and columns) based on target count.
        let rows = Math.round(Math.sqrt(params.target));
        let cols = Math.round(params.target / rows);
        rows = Math.max(rows, 1);
        cols = Math.max(cols, 1);

        // Compute the maximum cell height (h) such that the grid fits inside the circle.
        // Each rectangle's dimensions:
        //   cellHeight = h
        //   cellWidth = Math.round(params.aspectRatio * h)
        // Total grid dimensions:
        //   gridWidth = cols * cellWidth + (cols - 1) * gap
        //   gridHeight = rows * cellHeight + (rows - 1) * gap
        // The grid (centered at (120,120)) must satisfy:
        //   (gridWidth/2)^2 + (gridHeight/2)^2 <= 120^2
        let maxH = 0;
        const hMaxPossible = Math.floor(
          (canvas.height - (rows - 1) * params.gap) / rows
        );
        for (let h = hMaxPossible; h >= 1; h--) {
          const cellHeight = h;
          const cellWidth = Math.round(params.aspectRatio * h);
          const gridWidth = cols * cellWidth + (cols - 1) * params.gap;
          const gridHeight = rows * cellHeight + (rows - 1) * params.gap;
          if ((gridWidth / 2) ** 2 + (gridHeight / 2) ** 2 <= 120 ** 2) {
            maxH = h;
            break;
          }
        }

        if (maxH === 0) {
          console.error("Cannot fit grid with current parameters.");
          return [];
        }

        const cellHeight = maxH;
        const cellWidth = Math.round(params.aspectRatio * maxH);
        const gridWidth = cols * cellWidth + (cols - 1) * params.gap;
        const gridHeight = rows * cellHeight + (rows - 1) * params.gap;
        // Calculate offsets to center the grid within the canvas.
        const offsetX = Math.floor(120 - gridWidth / 2);
        const offsetY = Math.floor(120 - gridHeight / 2);

        const rectangles = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const x = offsetX + col * (cellWidth + params.gap);
            const y = offsetY + row * (cellHeight + params.gap);
            rectangles.push({
              x: x,
              y: y,
              width: cellWidth,
              height: cellHeight,
              color: [1, 1, 1, 1],
            });
          }
        }

        console.log(
          "Generated grid with",
          rows,
          "rows and",
          cols,
          "cols. Total:",
          rectangles.length
        );
        return rectangles;
      }

      // Render the scene: clear the canvas, draw the background circle,
      // then generate and draw the grid rectangles.
      function drawScene() {
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);
        gl.uniform2f(
          programInfo.uniformLocations.resolution,
          canvas.width,
          canvas.height
        );

        // Draw the container circle in light gray.
        drawCircle(120, 120, 120, [0.9, 0.9, 0.9, 1]);

        // Generate and draw grid rectangles.
        const rectangles = generateRectangles();
        rectangles.forEach((rect) => {
          drawRectangle(rect.x, rect.y, rect.width, rect.height, rect.color);
        });
      }

      // Draw a filled circle using TRIANGLE_FAN.
      function drawCircle(cx, cy, radius, color) {
        const numSegments = 100;
        const vertices = [];
        for (let i = 0; i <= numSegments; i++) {
          const angle = (i / numSegments) * 2 * Math.PI;
          vertices.push(
            cx + radius * Math.cos(angle),
            cy + radius * Math.sin(angle)
          );
        }

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW
        );

        gl.vertexAttribPointer(
          programInfo.attribLocations.position,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.position);
        gl.uniform4fv(programInfo.uniformLocations.color, color);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length / 2);
      }

      // Draw a filled rectangle.
      function drawRectangle(x, y, width, height, color) {
        const vertices = [
          x,
          y,
          x + width,
          y,
          x,
          y + height,
          x,
          y + height,
          x + width,
          y,
          x + width,
          y + height,
        ];

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW
        );

        gl.vertexAttribPointer(
          programInfo.attribLocations.position,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.position);
        gl.uniform4fv(programInfo.uniformLocations.color, color);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      // Initialize lil-gui and add controls.
      const gui = new lil.GUI();
      gui
        .add(params, "target", 1, 500, 1)
        .name("Target Rectangles")
        .onChange(drawScene);
      gui.add(params, "gap", 0, 20, 1).name("Gap (px)").onChange(drawScene);
      gui
        .add(params, "aspectRatio", 0.5, 2, 0.01)
        .name("Aspect Ratio")
        .onChange(drawScene);

      // Initial render
      drawScene();
    </script>
  </body>
</html>
